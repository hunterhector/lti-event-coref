/**
 *
 */
package edu.cmu.lti.event_coref.analysis_engine.resoluter;

import edu.cmu.lti.event_coref.model.EventCorefConstants;
import edu.cmu.lti.event_coref.type.EventCoreferenceCluster;
import edu.cmu.lti.event_coref.type.EventMention;
import edu.cmu.lti.event_coref.type.PairwiseEventCoreferenceEvaluation;
import edu.cmu.lti.event_coref.utils.eval.CorefChecker;
import edu.cmu.lti.utils.uima.UimaConvenience;
import org.apache.uima.analysis_engine.AnalysisEngineProcessException;
import org.apache.uima.fit.component.JCasAnnotator_ImplBase;
import org.apache.uima.fit.util.FSCollectionFactory;
import org.apache.uima.fit.util.JCasUtil;
import org.apache.uima.jcas.JCas;

import java.util.*;

/**
 * @author Zhengzhong Liu, Hector
 */
public class FullCoreferenceClusterTransitivityCreator extends
        JCasAnnotator_ImplBase {
    private final String ANNOTATOR_COMPONENT_ID = "System-Cluster-creation";

    /*
     * (non-Javadoc)
     *
     * @see
     * org.apache.uima.analysis_component.JCasAnnotator_ImplBase#process(org
     * .apache.uima.jcas.JCas)
     */
    @Override
    public void process(JCas aJCas) throws AnalysisEngineProcessException {

        Collection<PairwiseEventCoreferenceEvaluation> peceCorefEvals = JCasUtil
                .select(aJCas, PairwiseEventCoreferenceEvaluation.class);
        countSystemCluster(aJCas);
        clearSystemClusters(aJCas);
        createCluster(peceCorefEvals, aJCas);
        countSystemCluster(aJCas);
    }

    /**
     * Remove clusters generated by system, mainly to ensure no inconsistent
     * clustering different steps
     *
     * @param aJCas
     */
    private void clearSystemClusters(JCas aJCas) {
        List<EventCoreferenceCluster> cluster2Remove = new ArrayList<EventCoreferenceCluster>();
        for (EventCoreferenceCluster cluster : JCasUtil.select(aJCas,
                EventCoreferenceCluster.class)) {
            if (cluster.getComponentId().startsWith("System")) {
                cluster2Remove.add(cluster);
            }
        }
        for (EventCoreferenceCluster cluster : cluster2Remove) {
            cluster.removeFromIndexes(aJCas);
        }
    }

    /**
     * Remove clusters generated by system, mainly to ensure no inconsistent
     * clustering different steps
     *
     * @param aJCas
     */
    private void countSystemCluster(JCas aJCas) {
        int i = 0;
        for (EventCoreferenceCluster cluster : JCasUtil.select(aJCas,
                EventCoreferenceCluster.class)) {
            if (cluster.getComponentId().startsWith("System")) {
                i++;
            }
        }
        System.out.println(i + " system clusters");
    }

    /**
     * Create cluster
     *
     * @param peceCorefEvals
     * @return
     */
    private List<Set<EventMention>> createCluster(
            Collection<PairwiseEventCoreferenceEvaluation> peceCorefEvals,
            JCas aJCas) {

        List<Set<EventMention>> clusters = transtiveClosureCluster(peceCorefEvals);

        for (Set<EventMention> clusterSet : clusters) {
            EventCoreferenceCluster cluster = new EventCoreferenceCluster(aJCas);
            cluster.setChildEventMentions(FSCollectionFactory.createFSList(
                    aJCas, clusterSet));
            cluster.setComponentId(ANNOTATOR_COMPONENT_ID);
            cluster.setClusterType(EventCorefConstants.FULL_COREFERENCE_TYPE);
            cluster.addToIndexes();

            for (EventMention mention : clusterSet) {
                mention.setEventCoreferenceClusters(UimaConvenience.appendFSList(aJCas,
                        mention.getEventCoreferenceClusters(), cluster,
                        EventCoreferenceCluster.class));
            }
        }

        return clusters;
    }

    /**
     * A simple transitive closure method
     *
     * @param peceCorefEvals
     * @return
     */
    private List<Set<EventMention>> transtiveClosureCluster(
            Collection<PairwiseEventCoreferenceEvaluation> peceCorefEvals) {
        List<Set<EventMention>> fullCorefClusters = new ArrayList<Set<EventMention>>();
        for (PairwiseEventCoreferenceEvaluation pece : peceCorefEvals) {
            EventMention event1 = pece.getEventMentionI();
            EventMention event2 = pece.getEventMentionJ();

            if (CorefChecker.isFullSystem(pece)) {
                boolean inPreviousCluster = false;
                for (Set<EventMention> cluster : fullCorefClusters) {
                    if (cluster.contains(event1) || cluster.contains(event2)) {
                        cluster.add(event1);
                        cluster.add(event2);
                        inPreviousCluster = true;
                    }
                }

                if (!inPreviousCluster) {
                    // create a new cluster
                    Set<EventMention> cluster = new HashSet<EventMention>();
                    cluster.add(event1);
                    cluster.add(event2);
                    fullCorefClusters.add(cluster);
                }
            }
        }
        return fullCorefClusters;
    }
}